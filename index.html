<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="lib/css/reveal.min.css">
    <link rel="stylesheet" href="lib/css/crocodoc.viewer.css">
    <link rel="stylesheet" href="lib/css/reveal.default.css" id="theme">
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <link rel="stylesheet" href="css/slides.css">
<body tabindex="-1">
    <div class="reveal">
        <div class="slides">


            <!-- Intro -->

            <section>
                <h1>Embedding Complex SVGs Into HTML</h1>
                <br/>
                <h3>(AKA Crazy shit we did to make SVG work for us)</h3>

                <br/>
                <p>Cameron Lakenen &ndash; Box</p>
            </section>
            <section>
                The Box View API (formerly Crocodoc) is a service for generating portable, web-viewable versions of documents
                <aside class="notes" data-markdown>
                    The new Box preview and View API both use Crocodoc's HTML5 document conversion technology to render documents in the browser. My main focus is building a world-class document viewer on top of this technology.

                    Here's an example of the document viewer we've built. &rarr;
                </aside>
            </section>
            <section data-demo="viewer-example">
                <div class="demo-viewer"></div>
            </section>

            <!-- Background -->

            <section>
                We combine three web standards to render documents:
                <div class="logos">
                    <img class="fragment" data-fragment-index="1" src="images/html5.svg" />
                    <span class="fragment" data-fragment-index="3"><img class="fragment grow" data-fragment-index="3" src="images/svg.svg" /></span>
                    <img class="fragment" data-fragment-index="2" src="images/css3.svg" />
                </div>

                <aside class="notes" data-markdown>
                    Our document rendering strategy (as you might have guessed), is based on SVG
                </aside>
            </section>
            <section>
                <h2>Why SVG?</h2>

                <p data-markdown>*Can't you do everything with HTML + CSS?*</p>

                <aside class="notes" data-markdown>
                    HTML5 is awesome, you can do so much with it!
                    Unfortunately, aside from rendering to a canvas, it's not possible to use only HTML &rarr;
                </aside>
            </section>
            <section>
                <div data-markdown data-fragmentize>
                    <script type="text/template">
                    ## Why SVG?

                    * Functionality not available in HTML / CSS
                    * Standard, portable, and lightweight
                    * Incredibly high rendering fidelity
                    </script>
                </div>

                <aside class="notes" data-markdown>
                    so, why did we choose SVG? &rarr;

                    SVG provides some operations that aren't currently available with just HTML and CSS

                    * clipping and masking
                    * blending
                    * complex paths and subpixel positioning

                    though some of this functionality is on the horizon. &rarr;

                    Converted assets are all based on web standards, so they will just work in all standards-compliant browsers. Many other platforms are capable of interpreting and rendering SVG as well

                    SVG is just XML, just a text file, so it compresses very well on the wire, which is especially important for mobile &rarr;

                    SVG - scalable vector graphics have impeccable quality, with essentially infinite zooming that retains crispness (barring embedded rasterized images)
                </aside>
            </section>

            <section>
                <h2>Strokes and Fills</h2>
                <iframe class="demo-container" src="assets/svg-graphics/graphics.html"></iframe>
                <aside class="notes" data-markdown>
                </aside>
            </section>

            <section>
                <h2>Clipping, Masking, and Blending</h2>
                <iframe class="demo-container" src="assets/svg-graphics/graphics-adv.html"></iframe>
                <aside class="notes" data-markdown>
                </aside>
            </section>

            <section data-demo="viewer-zooming">
                <h2>Rendering Quality and Zooming</h2>
                <div class="demo-viewer"></div>

                <aside class="notes" data-markdown>
                </aside>
            </section>

            <!-- CANVAS (maybe cut this section) -->
            <section>
                <div data-markdown data-fragmentize>
                    <script type="text/template">
                    ## Why not canvas?

                    * Significantly more complex to render
                    * Requires JavaScript (less portable)
                    * Zooming and resizing requires full JS redraw

                    </script>
                </div>

                <aside class="notes" data-markdown>
                    So, what about canvas?

                    Canvas is a really interesting option for rendering documents, but is much more complex than SVG's declarative syntax

                    even though most of the time, our SVG assets are embedded dynamically using JS, it's not absolutely necessary.

                    SVG can be embedded as-is without JS. Canvas implementations would necessarily require JS, and are thus less portable

                    rendering to canvas requires either parsing and interpreting the document in JS or converting it to some set of operations beforehand that JS can then use to draw to a canvas.

                    furthermore, zooming or resizing a canvas element would require a redraw, unlike SVG

                    There are some interesting projects that render documents to Canvas, namely PDF.js, but for our purposes, SVG is a much better fit &rarr;
                </aside>
            </section>


            <!-- The Problem -->

            <section>
                <div data-markdown data-fragmentize>
                    <script type="text/template">
                    ## Several ways to embed SVG content

                    * `<img src="foo.svg">` and CSS `background-image`
                    * inline SVG (true inline vs DOMParser)
                    * `<object>`, `<iframe>`, or `<embed>`

                    </script>
                </div>
                <aside class="notes" data-markdown>
                    Having SVG as our rendering format has yielded many interesting problems for us when embedding in HTML

                    There are several ways to embed SVG content in HTML
                    * basic img tag or css background-image
                    * inline svg
                      * I'll talk about the what "true" inline SVG is, and what that means
                    * object, iframe, and embed tags
                      * I'll talk about these three tags and their differences (hint: there aren't really any differences)

                </aside>
            </section>

            <section>
                <div data-markdown data-fragmentize>
                    <script type="text/template">
                    ## Embedding issues

                    * Performance and stability ([#perfmatters](https://twitter.com/search?q=%23perfmatters&src=hash)!)
                    * Externally linked assets
                    * Browser loading indicator

                    </script>
                </div>
                <aside class="notes" data-markdown>
                    Each embed method has different implications regarding
                    * performance and stability
                      * rendering and layout performance, what it means for UI/scrolling/zooming peformance
                      * mobile stability and crashing and memory issues
                    * ability to load external assets or modify SVG content on the fly
                      * necessary for us because in some cases we need to rewrite relative paths to referenced assets in SVG or add queryString params for authentication and authorization purposes
                    * causing the native browser loading indicator
                      * it's annoying as all hell, and I'll show you what I mean by this, and how we were able to prevent it
                </aside>
            </section>

            <section>
                <div data-markdown data-fragmentize>
                    <script type="text/template">
                    ## Performance and Stability

                    * Lazyloading + scrolling and zooming performance
                    * Crashing mobile browsers (\*cough\* iOS)
                    </script>
                </div>
                <aside class="notes" data-markdown>
                    By far the biggest issue we face with SVG is performance. Some documents can be very complex, and therefore result in complex SVG files. We do as much as we can in the conversion process to reduce complexity for both file size and rendering performance reasons, but there is only so much that can be done without affecting rendering quality.

                    We have to lazy-load pages in order provide a faster, more responsive user experience, and embedding SVG on the fly can cause the UI to lock up with some embed methods, so certain methods yield better UI performance than others, and I'll explain these differences in a bit

                    Memory useage can vary as well with different embed methods (and lazy-loading range), and using too much memory is a sure fire way to crash mobile Safari

                    I'm not going to dive too deeply into mobile in this talk, because that could be a full talk by itself :) &rarr;
                </aside>
            </section>

            <section>
                <h2>External Assets</h2>
                <div class="demo-container small">
                    <iframe src="assets/inline/page-1.svg"></iframe> <img src="assets/inline/page-1.svg" />
                </div>
                <p class="" data-markdown>
                    <script type="text/template">
                    ```svg
                    <xhtml:link href="stylesheet.css" type="text/css" rel="stylesheet" />
                    <defs>
                        <image id="Image_8_1_R0zyIp" xlink:href="8.png" />
                        <image id="Image_10_1_R0zyIp" xlink:href="10.png" />
                    </defs>
                    ```
                    </script>
                </p>
                <aside class="notes" data-markdown>
                    For performance reasons, converted SVG assets link to other resources (e.g, images, fonts, stylesheets)

                    it is possible to base64 encode linked assets, which we do to some degree

                    but although *images* are not commonly reused across pages, fonts are often used across many or all pages.

                    if all necessary fonts are embedded into each individual svg file (instead of loaded in a common css file), it increases the total payload size by an unacceptable amount
                </aside>
            </section>

            <section data-demo="spinner-video">
                <h2>The Dreaded Spinner</h2>
                <video src="assets/spinner.m4v" loop></video>
                <p class="" data-markdown>
                    <script type="text/template">
                    ```html
                    <object type="image/svg+xml" data="foo.svg"></object>
                    ```
                    </script>
                </p>
                <aside class="notes" data-markdown>
                    Here's a short screencast I made of our document viewer using basic object embed

                    If you look closely at Chrome's *chrome* (hehe), you can see the loading indicator flicker like crazy while the viewer is loading pages. This is completely unacceptable behavior for our use case. &rarr;
                </aside>
            </section>

            <!-- embed methods -->

            <section>
                <h2>Embed Methods</h2>
                <ul>
                    <li class="fragment highlight-blue" data-markdown>
                        <script type="text/template">`<img src="foo.svg">` and CSS `background-image`</script>
                    </li>
                    <li>inline SVG (true inline vs DOMParser)</li>
                    <li data-markdown>
                        <script type="text/template">`<object>`, `<iframe>`, or `<embed>`</script>
                    </li>
                </ul>

                <aside class="notes" data-markdown>
                    So let's talk about the different embed methods! First, let's look at the img tag
                </aside>
            </section>

            <!-- IMG -->
            <section>
                <h2>The humble &lt;img&gt; tag</h2>
                <div><img src="assets/image-example.svg" height="400"/></div>

                <small><a href="http://www.schepers.cc/svg/blendups/embedding.html">http://www.schepers.cc/svg/blendups/embedding.html</a></small>
                <aside class="notes" data-markdown>
                    SVG is an image format after all, and &lt;img&gt; supports SVG files... the img tag even supports SVG animations!

                    Even CSS property background-image supports svg!

                    `&lt;img&gt;` tag supports SVG content pretty well, with the added bonus that it can be drawn to a canvas as a cache

                    Complex SVG can take time to layout and paint, and caching it to a canvas can protect against layout invalidation
                </aside>
            </section>
            <section>
                <h2>&lt;img&gt; tag: no external assets</h2>
                <p class="fragment" data-fragment-index="1">SVGs loaded via <code>&lt;img&gt;</code> won't fetch external assets</p>
                <div class="fragment demo-container small">
                    <img src="assets/inline/page-1.svg" />
                </div>

                <small class="fragment" data-fragment-index="1" data-markdown>https://developer.mozilla.org/en-US/docs/Web/SVG/SVG_as_an_Image#Restrictions</small>

                <aside class="notes" data-markdown>
                    Among other things, external assets aren't loaded when embedded with img tag (for security reasons)
                     (give an example of this)

                    For performane reasons, converted SVG files reference external assets (eg, fonts, images)

                    it is possible to base64 encode these assets and bake them into the SVG files

                    BUT although *images* are not commonly reused across pages, documents usually use the same set of fonts across many or all pages

                    if all necessary fonts were embedded into each individual svg file (instead of a common css file), it would increase the payload size by an unacceptable amount
                </aside>
            </section>
            <section>
                <h2>&lt;img&gt; tag: no external assets</h2>
                <p>Solution: base64-encode all assets into nested data: urls</p>
                <ul class="fragment">
                    <li>Very complex</li>
                    <li>Memory issues and crashing on mobile devices</li>
                </ul>

                <aside class="notes" data-markdown>
                    we attempted to load all assets
                    fonts, styles with ajax
                    images with new Image() + canvas.toDataURL()

                    and base64 encode (window.btoa()) them into one large data url

                    this was extremely complex, and didn't seem to work very well in all browsers

                    it could be explored further, but probably not work the effort

                    image performance seems to be worse than iframe for some reason (though this could be remedied by caching to canvas)

                    canvas has its own performance issues (re: memory usage), causes crashing on mobile

                    (this is why PDF.js doesn't work well/at all on most mobile devices)
                </aside>
            </section>
            <section>
                <h2>Embed methods</h2>

                <p>&lt;img&gt; is difficult at best &ndash; let's look at our other options:</p>

                <ul>
                    <li class="fragment highlight-red" data-markdown>
                        <script type="text/template">`<img src="foo.svg">`</script>
                    </li>
                    <li class="fragment highlight-blue">inline SVG (true inline vs DOMParser)</li>
                    <li data-markdown>
                        <script type="text/template">`<object>`, `<iframe>`, or `<embed>`</script>
                    </li>
                </ul>
                <aside class="notes" data-markdown>
                    img tag won't work for us. let's take a look at our other options...
                </aside>
            </section>

            <!-- INLINE -->

            <section>
                <h2>Inline SVG</h2>
                <p data-markdown>Inline SVG is part of the [HTML 5 spec](http://www.w3.org/html/wg/drafts/html/master/single-page.html#svg)!</p>
                <div data-svg-inline="assets/inline/page-1.svg" style="height: 375px; width: 500px"></div>
                <aside class="notes" data-markdown>
                    Inline SVG is great for static content rendered into the HTML page, but that wont work here
                </aside>
            </section>
            <section>
                <h2>DOMParser !== inline SVG*</h2>
                <p>SVG embedded with JS is not parsed asynchronously <span class="fragment" data-fragment-index="1">(yet**)</span></p>

                <small>*at least not in Chrome/Blink, and likely not in any browsers currently<br/>
                <span class="fragment" data-fragment-index="1">**<a href="http://crbug.com/308321">http://crbug.com/308321</a> and <a href="http://crbug.com/308768">http://crbug.com/308768</a></small>
                <aside class="notes" data-markdown>
                    In Box document viewer, pages are loaded dynamically, making it possible to load a 1000+ page document performantly

                    Inline SVG (literally HTML text with SVG text baked into it) is actually very fast in most browsers

                    In order to dynamically embed SVG content, it's necessary to use DOMParser or innerHTML to insert SVG content

                    At least in Chrome, invoking window.DOMParser bypasses the threaded html parser in Blink, which causes a synchronous parse of the SVG content
                    In fact, the threaded html parser is not exposed to JS at all, but this is something that could change in the near future - there are two chrome issues that are related to this
                </aside>
            </section>
            <section data-demo="viewer-inline">
                <h2>Inline (DOMParser)</h2>
                <div class="demo-viewer"></div>

                <aside class="notes" data-markdown>
                    This is an example document viewer that uses DOMParser to insert SVG into the DOM inline.

                    [scrolling] You might not be able to tell, but I'm scrolling right now... performance is pretty bad
                </aside>
            </section>
            <section data-demo="viewer-iframe">
                <h2>Iframe</h2>
                <div class="demo-viewer"></div>

                <aside class="notes" data-markdown>
                    This is the same document, but here the SVGs are embedded as iframes.

                    [scrolling] As you can see, performance is much better
                </aside>
            </section>
            <section data-demo="iframe-vs-inline">
                <h2>Iframe VS Inline (DOMParser)</h2>
                <div class="demo-container"></div>
                <button class="reload-iframe">Reload iframe</button>
                <button class="reload-inline">Reload inline</button>
                <button class="reload">Reload both</button>

                <aside class="notes" data-markdown>

                </aside>
            </section>

            <!-- IE9 stuff.. might remove this -->
            <section>
                <h2>Inline SVG and IE 9</h2>
                <ul>
                    <li>
                    Maximum of 31 stylesheets*<br/>
                    <ul><li><code>&lt;link rel="stylesheet"/&gt;</code>, <code>&lt;style&gt;</code></li></ul>
                    </li>
                    <li>
                    Hack to embed SVG with JS<br/>
                    <ul><li>no <code>document.importNode</code></li></ul>
                    </li>
                </ul>

                <small>*this has been removed in IE 10 (<a href="http://msdn.microsoft.com/en-US/library/ie/hh920762.aspx">http://msdn.microsoft.com/en-US/library/ie/hh920762.aspx</a>)</small>

                <aside class="notes" data-markdown>
                    In Box documents, each page includes a separate, page-specific style tag in addition to a common external css file. With inline SVG, this limit would be reached very quickly.

                    There is no document.importNode in IE 9, but luckily there's a relatively simple shim for it, which involes traversing the DOM tree and essentially making a copy of each node in the tree
                </aside>
            </section>
            <section>
                <h2>Embed methods</h2>

                <p>Inline SVG performance isn't quite there yet</p>

                <ul>
                    <li class="fragment highlight-red" data-markdown>
                        <script type="text/template">`<img src="foo.svg">`</script>
                    </li>
                    <li class="fragment highlight-red">inline SVG (true inline vs DOMParser)</li>
                    <li data-markdown class="fragment highlight-blue">
                        <script type="text/template">`<object>`, `<iframe>`, or `<embed>`</script>
                    </li>
                </ul>
                <aside class="notes" data-markdown>
                    img tag won't work for us. let's take a look at our other options...
                </aside>
            </section>

            <!-- IFRAME -->

            <section>
                <h2>Iframe vs Object vs Embed</h2>

                <p class="fragment">Effectively the same thing in most browsers</p>

                <aside class="notes" data-markdown>
                    In my testing, I've found that iframe, object, and embed are roughly equivalent when it comes to embedding SVG

                    For some reason, Firefox is happier with object tags, but otherwise iframe is fine

                    We don't bother with embed
                </aside>
            </section>
            <section>
                <h2>Proxy<span class="fragment" data-fragment-index="1">.svg</span><span class="fragment" data-fragment-index="2">.js</span></h2>

                <p class="fragment" data-fragment-index="1">proxy.svg: <em>an SVG file with some embedded JS</em></p>
                <p class="fragment" data-fragment-index="2">proxy.svg.js: <em>a JS file containing some SVG text that has some embedded JS</em></p>

                <aside class="notes" data-markdown>
                    Proxy.svg was our first attempt at a strategy that not only solves the annoying spinner issue, but also allows us to modify SVG content before it's loaded.

                    Unfortunately, we came up with the most complicated solution first, but I'll explain how it works, because it's kind of  interesting.

                    This method involves downloading SVG text via AJAX, modifying the content, and passing it to a child object which then injects the content into itself.

                    This resolves both the external assets issue (where we need to modify pathnames or add query parameters) and the browser loading indicator issue, because AJAX requests don't cause a spinner.

                    I'm going to use some illustrations to explain a slightly simplified version of this embed method... &rarr;
                </aside>
            </section>
            <section data-transition="none" class="proxy-example">
                <h2>Proxy.svg.js</h2>
                <img src="images/proxy-1.svg"/>
                <aside class="notes" data-markdown>
                    Here's viewer.js in its nice little Chrome tab

                    Let's assume we have already downloaded the SVG content via AJAX, and modified it as necessary, and we are ready to embed the SVG
                </aside>
            </section>
            <section data-transition="none" class="proxy-example">
                <h2>Proxy.svg.js</h2>
                <img src="images/proxy-2.svg"/>
                <p data-markdown>
                    <script type="text/template">
                    ```javascript
                    // viewer.js
                    var svgElement = document.createElement('object');
                    svgElement.type = 'image/svg+xml';
                    svgElement.data = 'data:image/svg+xml;base64,' + btoa(proxySVG);
                    pageElement.appendChild(svgElement);
                    ```
                    </script>
                </p>
                <aside class="notes" data-markdown>
                    Viewer.js embeds a child object via base64-encoded data:url of the proxy.svg container and scripts
                </aside>
            </section>
            <section data-transition="none" class="proxy-example">
                <h2>Proxy.svg.js</h2>
                <img src="images/proxy-3.svg"/>
                <p data-markdown>
                    <script type="text/template">
                    ```javascript
                    // viewer.js
                    window.addEventListener('message', handleProxyReadyMessage);
                    ```
                    </script>
                </p>
                <p data-markdown>
                    <script type="text/template">
                    ```javascript
                    // proxy.svg.js
                    window.parent.postMessage('ready', '*');
                    window.addEventListener('message', handleViewerMessage);
                    ```
                    </script>
                </p>
                <aside class="notes" data-markdown>
                    The proxy.svg script runs inside the newly created object, using the postMessage API to send a mesage to viewer.js in the parent window to alert the viewer that it has loaded and is ready to accept SVG content
                </aside>
            </section>
            <section data-transition="none" class="proxy-example">
                <h2>Proxy.svg.js</h2>
                <img src="images/proxy-4.svg"/>
                <p data-markdown>
                    <script type="text/template">
                    ```javascript
                    // viewer.js
                    function handleProxyReadyMessage(event) {
                        if (event.data === 'ready') {
                            svgElement.contentWindow.postMessage(svgContent, '*');
                        }
                    }
                    ```
                    </script>
                </p>
                <aside class="notes" data-markdown>
                    Viewer.js receives the message, and sends a message back containing the SVG content
                </aside>
            </section>
            <section data-transition="none" class="proxy-example">
                <h2>Proxy.svg.js</h2>
                <img src="images/proxy-5.svg"/>
                <p data-markdown>
                    <script type="text/template">
                    ```javascript
                    // proxy.svg.js
                    function handleViewerMessage(event) {
                        if (event.data) {
                            embedSVG(event.data);
                        }
                    }
                    ```
                    </script>
                </p>
                <aside class="notes" data-markdown>
                    The object embeds the SVG content directly into its documentElement using DOMParser and importNode
                </aside>
            </section>
            <section data-transition="none" class="proxy-example">
                <h2>Proxy.svg.js</h2>
                <img src="images/proxy-6.svg"/>
                <p data-markdown>
                    <script type="text/template">
                    ```javascript
                    // proxy.svg.js
                    window.parent.postMessage('loaded', '*');
                    ```
                    </script>
                </p>
                <aside class="notes" data-markdown>
                    After the SVG content is embedded, proxy.svg sends a message back to viewer.js to say that it's finished loading!
                </aside>
            </section>
            <section>
                <div data-markdown data-fragmentize>
                    ## Proxy.svg.js

                    * Too complicated
                    * Doesn't work in IE
                </div>
                <aside class="notes" data-markdown>
                    Proxy.svg was a very interesting solution, but was a little overly complex, and didn't work in internet explorer
                </aside>
            </section>
            <section>
                <div data-markdown data-fragmentize>
                    ## document.write()

                    * Create an empty `&lt;iframe&gt;`

                </div>
                <aside class="notes" data-markdown>
                    Our next solution was much simpler. It wasn't until after we finally needed to come up with a solution for internet explorer that we tried other options
                </aside>
            </section>
        </div>

        <div class="footer">
            <a href="https://twitter.com/lakenen">@lakenen</a><a href="https://twitter.com/search?q=%23html5devconf&src=hash">#html5devconf</a>
        </div>
    </div>

    <script src="lib/js/jquery.min.js"></script>
    <script src="lib/js/head.min.js"></script>
    <script src="lib/js/reveal.min.js"></script>
    <script src="lib/js/crocodoc.viewer.js"></script>
    <script src="js/timer.js"></script>
    <script src="js/data-svg.js"></script>
    <script src="js/slides.js"></script>
</body>
</html>
