<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="lib/css/reveal.min.css">
    <link rel="stylesheet" href="lib/css/crocodoc.viewer.min.css">
    <link rel="stylesheet" href="lib/css/reveal.default.css" id="theme">
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <link rel="stylesheet" href="css/slides.css">
<body tabindex="-1" class="contact">
    <div class="reveal">
        <div class="slides">
            <!-- Intro -->

            <section data-demo="contact">
                <h1>Embedding Complex SVGs Into HTML</h1>
                <br/>
                <h3>(AKA Crazy shit we did to make SVG work for us)</h3>

                <br/>
                <p>Cameron Lakenen &ndash; Box</p>


                <aside class="notes" data-markdown>
                    Cameron Lakenen

                    Engineer at Box

                    Preview and View API on document viewing stratgey in the brwoser

                    aventures in SVG&rarr;
                </aside>
                <!-- <aside class="notes" data-markdown>
                    Hi, my name is Cameron Lakenen, and I'm an engineer at Box, where I work on the new preview experience and the Box View API, *specifically* on the document viewing strategy in the browser.

                    I'm here to talk to you about my adventures in SVG over the past year &rarr;
                </aside> -->
            </section>

            <section>
                The Box View API (formerly Crocodoc) is a service for generating portable, web-viewable versions of documents
                <aside class="notes" data-markdown>
                    Preview and View API use Crocodoc

                    world-class document viewer &rarr;
                </aside>
                <!-- <aside class="notes" data-markdown>
                    The new Box preview and View API both use Crocodoc's HTML5 document conversion technology to render documents in the browser. My main focus is building a world-class document viewer on top of this technology. &rarr;
                </aside> -->
            </section>

            <section data-demo="viewer-example">
                <div class="demo-viewer"></div>

                <aside class="notes" data-markdown>
                    [scrolling] Here's an example of the document viewer we've built &rarr;
                </aside>
            </section>

            <!-- Background -->

            <section>
                We combine three web standards to render documents:
                <div class="logos">
                    <img class="fragment" data-fragment-index="1" src="images/html5.svg" />
                    <span class="fragment" data-fragment-index="3"><img class="fragment grow" data-fragment-index="3" src="images/svg.svg" /></span>
                    <img class="fragment" data-fragment-index="2" src="images/css3.svg" />
                </div>

                <aside class="notes" data-markdown>
                    rendering strategy is based on HTML5 &rarr;

                    CSS &rarr;

                    and SVG &rarr;
                </aside>
            </section>
            <section>
                <h2>Why SVG?</h2>

                <p data-markdown>*Can't you do everything with HTML + CSS?*</p>

                <aside class="notes" data-markdown>
                    HTML5 is great

                    aside from canvas it's not enough &rarr;
                </aside>
            </section>
            <section>
                <div data-markdown data-fragmentize>
                    <script type="text/template">
                    ## Why SVG?

                    * Functionality not available in HTML / CSS
                    * Standard, portable, and lightweight
                    * Incredibly high rendering fidelity
                    </script>
                </div>

                <aside class="notes" data-markdown>
                    so, why did we choose SVG? &rarr;

                    SVG provides some operations that aren't currently available with just HTML and CSS

                    * clipping and masking
                    * blending
                    * complex paths and subpixel positioning &rarr;

                    Converted assets are all based on web standards, so they will *just work* in all standards-compliant browsers. Many other platforms are capable of interpreting and rendering SVG as well

                    Furthermore, SVG is simply XML, *just a text file*, so it compresses very well on the wire, which is particularly important for mobile &rarr;

                    SVGs can also have impeccable quality, with infinite zooming that retains crisp edges &rarr;
                </aside>
            </section>

            <section>
                <h2>Strokes and Fills</h2>
                <iframe class="demo-container" src="assets/svg-graphics/graphics.html"></iframe>
                <aside class="notes" data-markdown>
                    One of the benefits SVG has over plain HTML/CSS is the ability to draw paths, for example simple stokes and fills, as well as simple text and images &rarr;
                </aside>
            </section>

            <section>
                <h2>Clipping, Masking, and Blending</h2>
                <iframe class="demo-container" src="assets/svg-graphics/graphics-adv.html"></iframe>
                <aside class="notes" data-markdown>
                    SVG can also do more complex graphics operations, such as clipping, masking and blending transparency groups &rarr;
                </aside>
            </section>

            <section data-demo="viewer-zooming">
                <h2>Rendering Quality and Zooming</h2>
                <div class="demo-viewer"></div>

                <aside class="notes" data-markdown>
                    SVG is terrific at zooming. The name, after all is "scalable vector graphics". As long as your content isn't composed completely of rasterized images, SVG files can scale infinitely and retain their crispness at any zoom level. &rarr;
                </aside>
            </section>

            <!-- CANVAS (maybe cut this section) -->
            <section>
                <div data-markdown data-fragmentize>
                    <script type="text/template">
                    ## Why not canvas?

                    * Significantly more complex to render
                    * Requires JavaScript (less portable)
                    * Zooming and resizing requires full JS redraw

                    </script>
                </div>

                <aside class="notes" data-markdown>
                    So, what about canvas? &rarr;

                    Canvas is a really interesting option for rendering documents, but is much more complex than SVG's declarative syntax &rarr;

                    even though most of the time our SVG assets are embedded dynamically using JS, it's not absolutely necessary.

                    SVG can be embedded as-is without JS, wheareas JS is necessary for Canvas implementations and are thus less portable

                    rendering to canvas requires either parsing and interpreting the document in JS or converting it to some set of operations beforehand that JS can then use to draw to a canvas. &rarr;

                    furthermore, zooming or resizing a canvas element would require a redraw, unlike SVG

                    There are some interesting projects that render documents to Canvas, eg., PDF.js, but for our purposes, SVG is a much better fit &rarr;
                </aside>
            </section>


            <!-- The Problem -->

            <section>
                <div data-markdown data-fragmentize>
                    <script type="text/template">
                    ## Several ways to embed SVG content

                    * `<img src="foo.svg">` and CSS `background-image`
                    * inline SVG (true inline vs DOMParser)
                    * `<object>`, `<iframe>`, or `<embed>`

                    </script>
                </div>
                <aside class="notes" data-markdown>
                    Having SVG as our rendering format has yielded many interesting problems for us when embedding in HTML

                    There are several ways to embed SVG content in HTML &rarr;

                    * basic img tag or css background-image &rarr;

                    * inline svg
                      * I'll talk about the what "true" inline SVG is &rarr;

                    * object, iframe, and embed tags
                      * I'll talk about these three tags and their differences (hint: there aren't really any differences) &rarr;

                </aside>
            </section>

            <section>
                <div data-markdown data-fragmentize>
                    <script type="text/template">
                    ## Embedding issues

                    * Performance and stability ([#perfmatters](https://twitter.com/search?q=%23perfmatters&src=hash)!)
                    * Externally linked assets
                    * Browser loading indicator

                    </script>
                </div>
                <aside class="notes" data-markdown>
                    Each embed method has different implications regarding &rarr;

                    * performance and stability
                      * I'll talk about rendering and layout performance, what it means for scrolling and zooming
                      * as well as mobile stability and memory issues &rarr;

                    * ability to load external assets or modify SVG content on the fly &rarr;

                    * causing the native browser loading indicator
                      * it's annoying as all hell, and I'll show you what I mean by this, and how we were able to prevent it &rarr;
                </aside>
            </section>

            <section>
                <div data-markdown data-fragmentize>
                    <script type="text/template">
                    ## Performance and Stability

                    * SVG complexity
                    * Lazyloading + scrolling and zooming performance
                    * Crashing mobile browsers (\*cough\* iOS)
                    </script>
                </div>
                <aside class="notes" data-markdown>
                    By far the biggest issue we face with SVG is performance. Some documents can be very complex, and therefore result in complex SVG files. We do as much as we can in the conversion process to reduce complexity for both file size and rendering performance reasons, but there is only so much that can be done without affecting rendering quality. &rarr;

                    We have to lazy-load pages in order provide a faster, more responsive user experience, and embedding SVG on the fly can cause the UI to be janky or even lock up, so certain methods yield better UI performance than others, and I'll explain these differences in a bit &rarr;

                    Memory useage can vary as well with different embed methods (and lazy-loading range), and using too much memory is a sure fire way to crash mobile Safari

                    I'm not going to dive too deeply into mobile in this talk, because that could be a full talk by itself :) &rarr;
                </aside>
            </section>

            <section>
                <div data-markdown data-fragmentize>
                    <script type="text/template">
                    ## External Assets

                    * Converted assets reference common fonts, images, etc
                    * Possible to base64-encode, but bad for performance
                    * Modify content on the fly
                    </script>
                </div>

                <aside class="notes" data-markdown>
                    For performance reasons, converted SVG assets link to common external resources (like images, fonts, stylesheets) &rarr;

                    external assets are great for re-using resources like fonts across multiple svg files

                    it is possible to base64 encode these assets, which we do to some degree, but although *images* are not commonly reused across pages, fonts are often used across many or all pages.

                    if all necessary fonts are embedded into each individual svg file (instead of loaded in a common css file), it increases the total payload size by an unacceptable amount &rarr;

                    it's also necessary for us to modify SVG content on the fly, because in some cases we need to rewrite relative paths to referenced assets in SVG or add queryString params for authentication and authorization purposes &rarr;
                </aside>
            </section>

            <section>
                <h2>External Assets</h2>
                <div class="demo-container small">
                    <iframe src="assets/inline/page-1.svg"></iframe> <img src="assets/inline/page-1.svg" />
                </div>
                <p class="" data-markdown>
                    <script type="text/template">
                    ```svg
                    <xhtml:link href="stylesheet.css" type="text/css" rel="stylesheet" />
                    <defs>
                        <image id="Image_8_1_R0zyIp" xlink:href="8.png" />
                        <image id="Image_10_1_R0zyIp" xlink:href="10.png" />
                    </defs>
                    ```
                    </script>
                </p>

                <aside class="notes" data-markdown>
                    In this example, I've included two copies of an SVG that references external assets. The one on the left works as expected, but the one on the right fails to load the assets, causing the embedded images and fonts to go missing
                </aside>
            </section>

            <section data-demo="spinner-video">
                <h2>The Dreaded Spinner</h2>
                <video src="assets/spinner.m4v" loop></video>
                <p class="" data-markdown>
                    <script type="text/template">
                    ```html
                    <object type="image/svg+xml" data="page-1.svg"></object>
                    ```
                    </script>
                </p>
                <aside class="notes" data-markdown>
                    Finally, the damn spinner. This is a big issue for us, because it's really annoying and jarring for the users.

                    Here's a short screencast I made of our document viewer using basic object embed

                    If you look closely at Chrome's, er... *chrome* (hehe), you can see the loading indicator flicker like crazy while the viewer is loading pages. This is completely unacceptable behavior for our use case. &rarr;
                </aside>
            </section>

            <!-- embed methods -->

            <section>
                <h2>Embed Methods</h2>
                <ul>
                    <li class="fragment highlight-blue" data-markdown>
                        <script type="text/template">`<img src="foo.svg">` and CSS `background-image`</script>
                    </li>
                    <li>inline SVG (true inline vs DOMParser)</li>
                    <li data-markdown>
                        <script type="text/template">`<object>`, `<iframe>`, or `<embed>`</script>
                    </li>
                </ul>

                <aside class="notes" data-markdown>
                    So let's talk about the different embed methods! &rarr;

                    First, let's look at the img tag &rarr;
                </aside>
            </section>

            <!-- IMG -->
            <section>
                <h2>The humble &lt;img&gt; tag</h2>
                <div><img src="assets/image-example.svg" height="400"/></div>

                <small><a href="http://www.schepers.cc/svg/blendups/embedding.html">http://www.schepers.cc/svg/blendups/embedding.html</a></small>
                <aside class="notes" data-markdown>
                    SVG is an image format after all, and `&lt;img&gt;` tag supports SVG files... the img tag even supports SVG animations!

                    Even the CSS property background-image supports svg!

                    `&lt;img&gt;` tag supports SVG content pretty well, with the added bonus that it can be drawn to a canvas as a cache

                    Complex SVG can take time to layout and paint, and caching it to a canvas can protect against layout invalidation
                </aside>
            </section>
            <section>
                <h2>&lt;img&gt; tag: no external assets</h2>
                <p class="fragment" data-fragment-index="1">SVGs loaded via <code>&lt;img&gt;</code> won't fetch external assets</p>
                <div class="fragment demo-container small">
                    <img src="assets/inline/page-1.svg" />
                </div>

                <small class="fragment" data-fragment-index="1" data-markdown>https://developer.mozilla.org/en-US/docs/Web/SVG/SVG_as_an_Image#Restrictions</small>

                <aside class="notes" data-markdown>
                    Unfortunately, external assets aren't loaded when embedded with img tag (for security reasons) &rarr;
                </aside>
            </section>
            <section>
                <h2>&lt;img&gt; tag: no external assets</h2>
                <p>Solution: base64-encode all assets into nested data: urls</p>
                <ul class="fragment">
                    <li>Very complex</li>
                    <li>Memory issues and crashing on mobile devices</li>
                </ul>

                <aside class="notes" data-markdown>
                    we attempted to load all assets with JS

                    fonts, styles with ajax

                    images with new Image() + canvas.toDataURL()

                    and base64 encode (window.btoa()) them into one large, nested data url

                    this was extremely complex, and didn't seem to work very well in all browsers

                    it could be explored further, but probably not worth the effort
                </aside>
            </section>
            <section>
                <h2>Embed methods</h2>

                <p>&lt;img&gt; is difficult at best &ndash; let's look at our other options:</p>

                <ul>
                    <li class="fragment highlight-red" data-markdown>
                        <script type="text/template">`<img src="foo.svg">`</script>
                    </li>
                    <li class="fragment highlight-blue">inline SVG</li>
                    <li data-markdown>
                        <script type="text/template">`<object>`, `<iframe>`, or `<embed>`</script>
                    </li>
                </ul>
                <aside class="notes" data-markdown>
                    img tag won't work for us. let's take a look at our other options... &rarr;
                </aside>
            </section>

            <!-- INLINE -->

            <section>
                <h2>Inline SVG</h2>
                <p data-markdown>Inline SVG is part of the [HTML 5 spec](http://www.w3.org/html/wg/drafts/html/master/single-page.html#svg)!</p>
                <div data-svg-inline="assets/inline/page-1.svg" style="height: 375px; width: 500px"></div>
                <aside class="notes" data-markdown>
                    Inline SVG seemed very promising. It's part of HTML5 spec, and it works in all modern browsers, including IE 9 and up &rarr;
                </aside>
            </section>
            <section>
                <h2>DOMParser !== inline SVG*</h2>
                <p>SVG embedded with JS is not parsed asynchronously <span class="fragment" data-fragment-index="1">(yet**)</span></p>

                <small>*at least not in Chrome/Blink, and likely not in any browsers currently<br/>
                <span class="fragment" data-fragment-index="1">**<a href="http://crbug.com/308321">http://crbug.com/308321</a> and <a href="http://crbug.com/308768">http://crbug.com/308768</a></small>
                <aside class="notes" data-markdown>
                    In Box document viewer, pages are loaded dynamically, making it possible to load a 1000+ page document performantly

                    Inline SVG (literally HTML text with SVG text baked into it) is actually very fast in most browsers

                    In order to dynamically embed SVG content, it's necessary to use DOMParser or innerHTML to insert SVG content

                    At least in Chrome, invoking window.DOMParser bypasses the threaded html parser in Blink, which causes a synchronous parse of the SVG content
                    In fact, the threaded html parser is not exposed to JS at all, but this is something that could change in the near future - there are two chrome issues that are related to this
                </aside>
            </section>
            <section data-demo="viewer-inline">
                <h2>Inline (DOMParser)</h2>
                <div class="demo-viewer"></div>

                <aside class="notes" data-markdown>
                    This is an example document viewer that uses DOMParser to insert SVG into the DOM inline.

                    [scrolling] You might not be able to tell, but I'm scrolling right now... performance is pretty bad
                </aside>
            </section>
            <section data-demo="viewer-iframe">
                <h2>Iframe</h2>
                <div class="demo-viewer"></div>

                <aside class="notes" data-markdown>
                    This is the same document, but here the SVGs are embedded as iframes.

                    [scrolling] As you can see, performance is much better
                </aside>
            </section>
            <section data-demo="iframe-vs-inline">
                <h2>Iframe VS Inline (DOMParser)</h2>
                <div class="demo-container"></div>
                <button class="reload-iframe">Reload iframe</button>
                <button class="reload-inline">Reload inline</button>
                <button class="reload">Reload both</button>

                <aside class="notes" data-markdown>
                In this example, I've placed and iframe and inline DOMParser example side-by-side. If I reload the example, you can clearly see the differences between the two methods. What's happening is that the DOMParser method on the right is taking the synchronous codepath, causing it to be parsed much slower than the iframe method, which uses the native async HTML parser.
                </aside>
            </section>

            <!-- IE9 stuff.. might remove this
            <section>
                <h2>Inline SVG and IE 9</h2>
                <ul>
                    <li>
                    Maximum of 31 stylesheets*<br/>
                    <ul><li><code>&lt;link rel="stylesheet"/&gt;</code>, <code>&lt;style&gt;</code></li></ul>
                    </li>
                    <li>
                    Hack to embed SVG with JS<br/>
                    <ul><li>no <code>document.importNode</code></li></ul>
                    </li>
                </ul>

                <small>*this has been removed in IE 10 (<a href="http://msdn.microsoft.com/en-US/library/ie/hh920762.aspx">http://msdn.microsoft.com/en-US/library/ie/hh920762.aspx</a>)</small>

                <aside class="notes" data-markdown>
                    In Box documents, each page includes a separate, page-specific style tag in addition to a common external css file. With inline SVG, this limit would be reached very quickly.

                    There is no document.importNode in IE 9, but luckily there's a relatively simple shim for it, which involes traversing the DOM tree and essentially making a copy of each node in the tree
                </aside>
            </section> -->
            <section>
                <h2>Embed methods</h2>

                <p>Inline SVG performance isn't quite there yet</p>

                <ul>
                    <li class="fragment highlight-red" data-markdown>
                        <script type="text/template">`<img src="foo.svg">`</script>
                    </li>
                    <li class="fragment highlight-red">inline SVG</li>
                    <li data-markdown class="fragment highlight-blue">
                        <script type="text/template">`<object>`, `<iframe>`, or `<embed>`</script>
                    </li>
                </ul>
                <aside class="notes" data-markdown>
                    img tag won't work for us. let's take a look at our other options...
                </aside>
            </section>

            <!-- IFRAME -->

            <section>
                <h2>Iframe vs Object vs Embed</h2>

                <p class="fragment">Effectively the same thing in most browsers</p>

                <aside class="notes" data-markdown>
                    In my testing, I've found that iframe, object, and embed are roughly equivalent when it comes to embedding SVG

                    For some reason, Firefox is happier with object tags, but otherwise iframe is fine

                    We don't bother with embed
                </aside>
            </section>

            <section>
                <div data-markdown data-fragmentize>
                ## Basic embed via iframe/object

                * Spinner :(
                * Can't modify text before loading

                ```html
                &lt;iframe type="text/svg+xml" src="page-1.svg"&gt;&lt;/iframe&gt;
                &lt;object type="text/svg+xml" data="page-1.svg"&gt;&lt;/object&gt;
                ```
                </div>

                <aside class="notes" data-markdown>
                    Unfortunately, embedding SVG with the iframe or object tags directly doesn't solve our problems, although performance is great. &rarr;

                    There's still a spinner every time you load a page &rarr;

                    It's not possible to modify content before it's loaded, because the iframe/object requests the svg file directly &rarr;
                </aside>
            </section>

            <!-- proxy.svg -->

            <section>
                <h2>Proxy-SVG</h2>

                <p>Embed object as a tiny SVG that contains a bit of JS</p>

<pre class="fragment"><code class="javascript" data-trim>
// proxy-svg.js

function proxyScript() {
    /* proxy JS code */
}

var SVG = '&lt;svg version="1.1" xmlns="http://www.w3.org/2000/svg"&gt;' +
    '&lt;script&gt;&lt;![CDATA[(' + proxyScript.toString() + ')()]]&gt;&lt;/script&gt;' +
    '&lt;/svg&gt;';

var object = document.createElement('object');
object.type = 'image/svg+xml';
object.data = 'data:image/svg+xml;base64,' + window.btoa(SVG);
</code></pre>

                <aside class="notes" data-markdown>
                    Proxy-svg was our first attempt at an iframe/object-based embed strategy that not only solves the annoying spinner issue, but also allows us to modify SVG content before it's loaded.

                    Unfortunately, we came up with the most complicated solution first, but I'll explain how it works, because it's kind of  interesting.

                    This method involves downloading SVG text via AJAX, modifying the content, and passing it to a child object which then injects the content into itself.

                    I'm going to use some illustrations to explain a slightly simplified version of this embed method... &rarr;
                </aside>
            </section>
            <section data-transition="none" class="proxy-example">
                <h2>Proxy.svg.js</h2>
                <img src="images/proxy-1.svg"/>
                <aside class="notes" data-markdown>
                    Here's viewer.js in its nice little Chrome tab

                    Let's assume we have already downloaded the SVG content via AJAX, and modified it as necessary, and we are ready to embed the SVG
                </aside>
            </section>
            <section data-transition="none" class="proxy-example">
                <h2>Proxy.svg.js</h2>
                <img src="images/proxy-2.svg"/>
                <p data-markdown>
                    <script type="text/template">
                    ```javascript
                    // viewer.js
                    var svgElement = document.createElement('object');
                    svgElement.type = 'image/svg+xml';
                    svgElement.data = 'data:image/svg+xml;base64,' + btoa(proxySVG);
                    pageElement.appendChild(svgElement);
                    ```
                    </script>
                </p>
                <aside class="notes" data-markdown>
                    The parent window embeds a child object via base64-encoded data:url of the proxy.svg script
                </aside>
            </section>
            <section data-transition="none" class="proxy-example">
                <h2>Proxy.svg.js</h2>
                <img src="images/proxy-3.svg"/>
                <p data-markdown>
                    <script type="text/template">
                    ```javascript
                    // viewer.js
                    window.addEventListener('message', handleProxyReadyMessage);
                    ```
                    </script>
                </p>
                <p data-markdown>
                    <script type="text/template">
                    ```javascript
                    // proxy.svg.js
                    window.parent.postMessage('ready', '*');
                    window.addEventListener('message', handleViewerMessage);
                    ```
                    </script>
                </p>
                <aside class="notes" data-markdown>
                    The proxy.svg script runs inside the newly created object, using the postMessage API to send a mesage to the parent window, which alerts the viewer that it has loaded and is ready to accept SVG content
                </aside>
            </section>
            <section data-transition="none" class="proxy-example">
                <h2>Proxy.svg.js</h2>
                <img src="images/proxy-4.svg"/>
                <p data-markdown>
                    <script type="text/template">
                    ```javascript
                    // viewer.js
                    function handleProxyReadyMessage(event) {
                        if (event.data === 'ready') {
                            svgElement.contentWindow.postMessage(svgContent, '*');
                        }
                    }
                    ```
                    </script>
                </p>
                <aside class="notes" data-markdown>
                    The parent window receives the message, and sends a message containing the SVG content back to the object
                </aside>
            </section>
            <section data-transition="none" class="proxy-example">
                <h2>Proxy.svg.js</h2>
                <img src="images/proxy-5.svg"/>
                <p data-markdown>
                    <script type="text/template">
                    ```javascript
                    // proxy.svg.js
                    function handleViewerMessage(event) {
                        if (event.data) {
                            embedSVG(event.data);
                        }
                    }
                    ```
                    </script>
                </p>
                <aside class="notes" data-markdown>
                    The object embeds the SVG content directly into its documentElement using DOMParser and importNode
                </aside>
            </section>
            <section data-transition="none" class="proxy-example">
                <h2>Proxy.svg.js</h2>
                <img src="images/proxy-6.svg"/>
                <p data-markdown>
                    <script type="text/template">
                    ```javascript
                    // proxy.svg.js
                    window.parent.postMessage('loaded', '*');
                    ```
                    </script>
                </p>
                <aside class="notes" data-markdown>
                    After the SVG content is embedded, proxy.svg sends a message back to the parent window to say that it's finished loading!
                </aside>
            </section>
            <section>
                <div data-markdown data-fragmentize>
                    ## Proxy.svg.js

                    * Too complicated
                    * Doesn't work in IE (no scripts in data:urls)
                </div>
                <aside class="notes" data-markdown>
                    Proxy.svg was a very interesting solution &rarr;

                    but was a little overly complex &rarr;

                    and didn't work in internet explorer

                    Once we finally needed to support internet explorer, we searched for other options &rarr;
                </aside>
            </section>

            <!-- document.write() -->

            <section>
                <div data-markdown data-fragmentize>
                    ## document.write()

                    * Create an empty `&lt;iframe src=""&gt;`
                    * `document.write()` writes SVG directly into iframe

                </div>
                <p data-markdown class="fragment">
                    <script type="text/template">
                    ```javascript
                    var iframe = document.createElement('iframe');
                    pageElement.appendChild(iframe);
                    iframe.contentDocument.open();
                    iframe.contentDocument.write(htmlHeader + svgContent);
                    iframe.contentDocument.close();
                    ```
                    </script>
                </p>
                <aside class="notes" data-markdown>
                    Our next solution was much simpler. &rarr;

                    Basically, create an empty iframe with no src attribute

                    since this is considered same domain, you can interact directly with the iframe's contentWindow without worrying about the browser's security policy&rarr;

                    this allows us to call document.write() from the parent window, and write the SVG content directly into the iframe
                </aside>
            </section>
            <section>
                <div data-markdown data-fragmentize>
                    ## document.write()

                    * Works very well in Chrome and IE
                    * Works in FF/Safari, minus `&lt;defs&gt;` bug
                    * Causes spinner in FF
                </div>
                <aside class="notes" data-markdown>
                    This solution works very well in every browser, &rarr;

                    but there were some unfortunate bugs in Firefox and Safari. &rarr;

                    Namely, anything in the `&lt;defs&gt;` tag seems to be ignored by the browser.

                    Referencing the images directly fixes the problem, but we put our images in the defs tag so they can be reused throughout the page (which is often the case), so the defs tag is very important &rarr;

                    Also, document.write() causes a spinner in Firefox, which, of course, is unacceptable. &rarr;
                </aside>
            </section>

            <!-- direct proxy -->

            <section>
                <h2>"Direct Proxy"</h2>

                <ul>
                    <li class="fragment" data-fragment-inedx="1">Combination of Proxy.svg and document.write() methods</li>
                    <li class="fragment" data-fragment-inedx="2">Safari - create an iframe, write a script with document.write()</li>
                    <li class="fragment" data-fragment-inedx="2">Firefox - create an object with data:url encoded script</li>
                    <li class="fragment" data-fragment-inedx="3">Call script directly from parent window (viewer.js)</li>
                </ul>
                <aside class="notes" data-markdown>
                    In order to get around the bugs in Firefox and Safari, we had to come up with yet another solution, which I call, for lack of a better name "direct proxy" &rarr;

                    This solution kind of combines proxy.svg and document.write() strategies in a simple way.

                    In this strategy, we initialize an empty object or iframe with a simple script (similar to proxy.svg) &rarr;

                    The trick is, in this method, the object is initialized in such a way that the browser's security policy doesn't interfere with direct frame-to-frame communication &rarr;

                    The embedded script takes an SVG string and embeds it into the frame's documentElement with DOMParser


                </aside>
            </section>

            <section>
                <div data-markdown>
                    ## "Direct Proxy"
                </div>
                <p data-markdown>
                    <script type="text/template">
                    ```javascript
                    // to be stringified in the data:url and run inside the child frame
                    function proxySVG() {
                        // actually loads the SVG; called from the parent window
                        window.loadSVG = function (svgText) {
                            // parse the SVG text
                            var dp = new window.DOMParser(),
                                svgDoc = dp.parseFromString(svgText, 'image/svg+xml');

                            // import the SVG node
                            svgDoc = document.importNode(svgDoc.documentElement, true);

                            // append it!
                            document.documentElement.appendChild(svgEl);
                        };
                    }
                    var proxyScript = '<script><![CDATA[('+proxySVG+')()]]><'+'/script>';
                    ```
                    </script>
                </p>
                <aside class="notes" data-markdown>
                    This is what the embedded "proxy" script looks like
                </aside>
            </section>

            <section>
                <div data-markdown>
                    ## "Direct Proxy" - Firefox
                </div>
                <p data-markdown>
                    <script type="text/template">
                    ```javascript
                    var object = document.createElement('object');
                    object.type = 'image/svg+xml';
                    object.data = 'data:image/svg+xml,<svg>'+proxyScript+'</svg>';
                    object.onload = function () {
                        object.contentWindow.loadSVG(svgContent);
                    };
                    ```
                    </script>
                </p>
                <aside class="notes" data-markdown>
                    In firefox, since the browser's security policy considers data:urls the same domain as the parent, we can simply encode the proxy script into a data:url, embed it as an object, then call the method directly
                </aside>
            </section>

            <section>
                <div data-markdown>
                    ## "Direct Proxy" - Safari
                </div>
                <p data-markdown>
                    <script type="text/template">
                    ```javascript
                    var iframe = document.createElement('iframe');
                    iframe.open();
                    iframe.write(proxyScript);
                    iframe.close();
                    iframe.onload = function () {
                        iframe.contentWindow.loadSVG(svgContent);
                    };
                    ```
                    </script>
                </p>
                <aside class="notes" data-markdown>
                    In other browsers, we can use a similar method to document.write() the script into an iframe, and call the method directly on the iframe's contentWindow
                </aside>
            </section>

            <!-- closing -->

            <section>
                <div data-markdown>
                    ## "Direct Proxy"

                    * Solves the `&lt;defs&gt;` bug in FF/Safari
                    * No spinner in Firefox!
                </div>
                <aside class="notes" data-markdown>
                    The direct proxy method, although slightly more complex (and possibly less performant) than simple document.write(), seems to solve our problems in Safari and Firefox.
                </aside>
            </section>

            <section data-demo="contact">
                <div data-markdown data-fragmentize>
                    # Questions?
                </div>

                <aside class="notes" data-markdown>
                    Anyways, thanks for sitting through what was basically a long rant about my adventures in SVG. Please feel free to ask me any questions, and I'll do my best to answer them!
                </aside>
            </section>
        </div>

        <div class="footer">
            <a href="https://twitter.com/lakenen">@lakenen</a><a href="https://twitter.com/search?q=%23html5devconf&src=hash">#html5devconf</a>
        </div>
    </div>

    <script src="lib/js/jquery.min.js"></script>
    <script src="lib/js/head.min.js"></script>
    <script src="lib/js/reveal.min.js"></script>
    <script src="lib/js/crocodoc.viewer.min.js"></script>
    <script src="js/timer.js"></script>
    <script src="js/data-svg.js"></script>
    <script src="js/slides.js"></script>
</body>
</html>
